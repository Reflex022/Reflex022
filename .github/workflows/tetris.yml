name: Tetris Game

on:
  issues:
    types: [opened]

jobs:
  move:
    if: startsWith(github.event.issue.title, 'Tetris|')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install Dependencies
        run: npm install @actions/github @actions/core fs-extra

      - name: Create Tetris Game Board
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        run: |
          mkdir -p dist
          cat > play-tetris.js << 'EOL'
          const fs = require('fs-extra');
          const github = require('@actions/github');
          const core = require('@actions/core');

          // مقاسات لوحة Tetris
          const WIDTH = 10;
          const HEIGHT = 20;
          
          // الألوان والأشكال
          const COLORS = {
            0: 'lightgrey',   // فارغ
            1: '#00C6FF',     // I قطعة
            2: '#7FDBFF',     // J قطعة
            3: '#0072FF',     // L قطعة
            4: '#66CFFF',     // O قطعة
            5: '#4FC3F7',     // S قطعة
            6: '#29B6F6',     // T قطعة
            7: '#03A9F4',     // Z قطعة
          };
          
          // قوالب الأشكال
          const SHAPES = [
            [], // فارغ (لا يستخدم)
            [[1, 1, 1, 1]],   // I
            [[2, 0, 0], [2, 2, 2]],  // J
            [[0, 0, 3], [3, 3, 3]],  // L
            [[4, 4], [4, 4]],  // O
            [[0, 5, 5], [5, 5, 0]],  // S
            [[0, 6, 0], [6, 6, 6]],  // T
            [[7, 7, 0], [0, 7, 7]],  // Z
          ];
          
          // إنشاء لوحة جديدة
          function createNewBoard() {
            const board = [];
            for (let y = 0; y < HEIGHT; y++) {
              board[y] = [];
              for (let x = 0; x < WIDTH; x++) {
                board[y][x] = 0;
              }
            }
            return board;
          }
          
          // حفظ حالة اللعبة في ملف
          function saveGameState(state) {
            fs.writeJSONSync('./dist/tetris-state.json', state);
          }
          
          // قراءة حالة اللعبة من ملف
          function loadGameState() {
            try {
              return fs.readJSONSync('./dist/tetris-state.json');
            } catch (e) {
              // إنشاء لعبة جديدة
              const state = {
                board: createNewBoard(),
                currentPiece: getRandomPiece(),
                piecePosition: { x: 3, y: 0 },
                score: 0,
                gameOver: false
              };
              saveGameState(state);
              return state;
            }
          }
          
          // إنشاء قطعة عشوائية
          function getRandomPiece() {
            return Math.floor(Math.random() * 7) + 1; // 1-7
          }
          
          // التحقق من التصادم
          function checkCollision(board, piece, position) {
            const shape = SHAPES[piece];
            for (let y = 0; y < shape.length; y++) {
              for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x] !== 0) {
                  const boardX = position.x + x;
                  const boardY = position.y + y;
                  
                  // خارج حدود اللوحة
                  if (boardX < 0 || boardX >= WIDTH || boardY >= HEIGHT) {
                    return true;
                  }
                  
                  // تحقق من الاصطدام مع قطع أخرى
                  if (boardY >= 0 && board[boardY][boardX] !== 0) {
                    return true;
                  }
                }
              }
            }
            return false;
          }
          
          // إضافة القطعة إلى اللوحة
          function mergePieceToBoard(board, piece, position) {
            const shape = SHAPES[piece];
            const newBoard = JSON.parse(JSON.stringify(board));
            
            for (let y = 0; y < shape.length; y++) {
              for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x] !== 0) {
                  const boardX = position.x + x;
                  const boardY = position.y + y;
                  
                  if (boardY >= 0 && boardY < HEIGHT && boardX >= 0 && boardX < WIDTH) {
                    newBoard[boardY][boardX] = shape[y][x];
                  }
                }
              }
            }
            
            return newBoard;
          }
          
          // التحقق من الصفوف المكتملة وإزالتها
          function clearLines(board) {
            let newBoard = JSON.parse(JSON.stringify(board));
            let linesCleared = 0;
            
            for (let y = HEIGHT - 1; y >= 0; y--) {
              let lineIsFull = true;
              
              for (let x = 0; x < WIDTH; x++) {
                if (newBoard[y][x] === 0) {
                  lineIsFull = false;
                  break;
                }
              }
              
              if (lineIsFull) {
                linesCleared++;
                
                // تحريك جميع الصفوف فوق الصف المكتمل للأسفل
                for (let yy = y; yy > 0; yy--) {
                  for (let x = 0; x < WIDTH; x++) {
                    newBoard[yy][x] = newBoard[yy-1][x];
                  }
                }
                
                // تفريغ الصف العلوي
                for (let x = 0; x < WIDTH; x++) {
                  newBoard[0][x] = 0;
                }
                
                // إعادة فحص نفس الصف مرة أخرى (لأنه الآن يحتوي على صف جديد)
                y++;
              }
            }
            
            return { newBoard, linesCleared };
          }
          
          // رسم اللوحة كصورة SVG
          function drawBoard(state) {
            const CELL_SIZE = 20;
            const BOARD_WIDTH = WIDTH * CELL_SIZE;
            const BOARD_HEIGHT = HEIGHT * CELL_SIZE;
            
            let svg = `<svg width="${BOARD_WIDTH + 100}" height="${BOARD_HEIGHT + 50}" xmlns="http://www.w3.org/2000/svg">
            <rect width="100%" height="100%" fill="#0d1117" />
            <text x="${BOARD_WIDTH + 50}" y="30" font-family="Arial" font-size="16" fill="#00C6FF" text-anchor="middle">Score: ${state.score}</text>`;
            
            // رسم حدود اللوحة
            svg += `<rect x="0" y="0" width="${BOARD_WIDTH}" height="${BOARD_HEIGHT}" fill="none" stroke="#00C6FF" stroke-width="2" />`;
            
            // رسم الخلايا الثابتة
            for (let y = 0; y < HEIGHT; y++) {
              for (let x = 0; x < WIDTH; x++) {
                if (state.board[y][x] !== 0) {
                  svg += `<rect x="${x * CELL_SIZE}" y="${y * CELL_SIZE}" width="${CELL_SIZE}" height="${CELL_SIZE}" fill="${COLORS[state.board[y][x]]}" stroke="#0d1117" stroke-width="1" />`;
                }
              }
            }
            
            // رسم القطعة الحالية
            if (!state.gameOver) {
              const shape = SHAPES[state.currentPiece];
              for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                  if (shape[y][x] !== 0) {
                    const boardX = state.piecePosition.x + x;
                    const boardY = state.piecePosition.y + y;
                    
                    if (boardY >= 0 && boardY < HEIGHT && boardX >= 0 && boardX < WIDTH) {
                      svg += `<rect x="${boardX * CELL_SIZE}" y="${boardY * CELL_SIZE}" width="${CELL_SIZE}" height="${CELL_SIZE}" fill="${COLORS[shape[y][x]]}" stroke="#0d1117" stroke-width="1" />`;
                    }
                  }
                }
              }
            }
            
            // أزرار التحكم
            const buttonY = BOARD_HEIGHT + 30;
            svg += `<a href="https://github.com/Reflex022/Reflex022/issues/new?title=Tetris%7CLeft&body=Move+Left">
              <rect x="${BOARD_WIDTH/2 - 110}" y="${buttonY}" width="50" height="30" rx="5" fill="#00C6FF" />
              <text x="${BOARD_WIDTH/2 - 85}" y="${buttonY + 20}" font-family="Arial" font-size="16" fill="white" text-anchor="middle">←</text>
            </a>`;
            
            svg += `<a href="https://github.com/Reflex022/Reflex022/issues/new?title=Tetris%7CRight&body=Move+Right">
              <rect x="${BOARD_WIDTH/2 - 50}" y="${buttonY}" width="50" height="30" rx="5" fill="#00C6FF" />
              <text x="${BOARD_WIDTH/2 - 25}" y="${buttonY + 20}" font-family="Arial" font-size="16" fill="white" text-anchor="middle">→</text>
            </a>`;
            
            svg += `<a href="https://github.com/Reflex022/Reflex022/issues/new?title=Tetris%7CRotate&body=Rotate">
              <rect x="${BOARD_WIDTH/2 + 10}" y="${buttonY}" width="50" height="30" rx="5" fill="#00C6FF" />
              <text x="${BOARD_WIDTH/2 + 35}" y="${buttonY + 20}" font-family="Arial" font-size="16" fill="white" text-anchor="middle">↻</text>
            </a>`;
            
            svg += `<a href="https://github.com/Reflex022/Reflex022/issues/new?title=Tetris%7CDrop&body=Drop">
              <rect x="${BOARD_WIDTH/2 + 70}" y="${buttonY}" width="50" height="30" rx="5" fill="#00C6FF" />
              <text x="${BOARD_WIDTH/2 + 95}" y="${buttonY + 20}" font-family="Arial" font-size="16" fill="white" text-anchor="middle">↓</text>
            </a>`;
            
            // رسالة Game Over
            if (state.gameOver) {
              svg += `<rect x="50" y="${BOARD_HEIGHT/2 - 40}" width="${BOARD_WIDTH - 100}" height="80" rx="10" fill="rgba(255,255,255,0.9)" />
              <text x="${BOARD_WIDTH/2}" y="${BOARD_HEIGHT/2}" font-family="Arial" font-size="24" fill="#FF0000" text-anchor="middle">GAME OVER</text>
              <text x="${BOARD_WIDTH/2}" y="${BOARD_HEIGHT/2 + 30}" font-family="Arial" font-size="16" fill="#000000" text-anchor="middle">Score: ${state.score}</text>
              <a href="https://github.com/Reflex022/Reflex022/issues/new?title=Tetris%7CNewGame&body=Start+New+Game">
                <rect x="${BOARD_WIDTH/2 - 60}" y="${BOARD_HEIGHT/2 + 50}" width="120" height="30" rx="5" fill="#00C6FF" />
                <text x="${BOARD_WIDTH/2}" y="${BOARD_HEIGHT/2 + 70}" font-family="Arial" font-size="14" fill="white" text-anchor="middle">New Game</text>
              </a>`;
            }
            
            svg += `</svg>`;
            
            return svg;
          }
          
          // معالجة الحركات
          function processMove(move) {
            let state = loadGameState();
            
            if (move === 'NewGame') {
              state = {
                board: createNewBoard(),
                currentPiece: getRandomPiece(),
                piecePosition: { x: 3, y: 0 },
                score: 0,
                gameOver: false
              };
              saveGameState(state);
              return state;
            }
            
            if (state.gameOver) {
              return state;
            }
            
            let newPosition = { ...state.piecePosition };
            let currentPiece = state.currentPiece;
            
            // تطبيق الحركة
            switch (move) {
              case 'Left':
                newPosition.x -= 1;
                break;
              case 'Right':
                newPosition.x += 1;
                break;
              case 'Rotate':
                // بتبسيط، سنقوم بتغيير القطعة إلى القطعة التالية
                currentPiece = currentPiece % 7 + 1;
                break;
              case 'Drop':
                // تحريك القطعة للأسفل حتى تصطدم
                while (!checkCollision(state.board, state.currentPiece, { ...newPosition, y: newPosition.y + 1 })) {
                  newPosition.y += 1;
                }
                break;
              default:
                // حركة للأسفل تلقائية
                newPosition.y += 1;
            }
            
            // التحقق من الاصطدام
            if (checkCollision(state.board, currentPiece, newPosition)) {
              // إذا كانت حركة غير صالحة، نعيدها
              if (move === 'Left' || move === 'Right' || move === 'Rotate') {
                newPosition = { ...state.piecePosition };
                currentPiece = state.currentPiece;
              } else {
                // إذا كانت حركة نزول وحدث اصطدام
                // نضيف القطعة إلى اللوحة
                state.board = mergePieceToBoard(state.board, state.currentPiece, state.piecePosition);
                
                // تنظيف الصفوف المكتملة
                const { newBoard, linesCleared } = clearLines(state.board);
                state.board = newBoard;
                state.score += linesCleared * 100;
                
                // إنشاء قطعة جديدة
                state.currentPiece = getRandomPiece();
                state.piecePosition = { x: 3, y: 0 };
                
                // التحقق مما إذا كانت اللعبة انتهت
                if (checkCollision(state.board, state.currentPiece, state.piecePosition)) {
                  state.gameOver = true;
                }
                
                saveGameState(state);
                return state;
              }
            }
            
            // تحديث حالة اللعبة
            state.currentPiece = currentPiece;
            state.piecePosition = newPosition;
            
            saveGameState(state);
            return state;
          }
          
          // معالجة الحدث الرئيسي
          async function run() {
            try {
              const issueTitle = process.env.ISSUE_TITLE;
              const move = issueTitle.split('|')[1];
              
              const token = process.env.GITHUB_TOKEN;
              const octokit = github.getOctokit(token);
              
              // معالجة الحركة
              const state = processMove(move);
              
              // إنشاء صورة SVG للحالة الجديدة
              const svgContent = drawBoard(state);
              fs.writeFileSync('./dist/tetris.svg', svgContent);
              
              // الرد على Issue
              await octokit.rest.issues.createComment({
                ...github.context.repo,
                issue_number: github.context.issue.number,
                body: `Move processed: ${move}\nCurrent score: ${state.score}\n\n![Tetris Board](https://github.com/Reflex022/Reflex022/blob/output/tetris.svg)`
              });
              
              // إغلاق Issue
              await octokit.rest.issues.update({
                ...github.context.repo,
                issue_number: github.context.issue.number,
                state: 'closed'
              });
              
            } catch (error) {
              core.setFailed(error.message);
            }
          }
          
          run();
          EOL
          
          node play-tetris.js

      - name: Setup Git User
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Commit and Push
        run: |
          git add dist/tetris.svg dist/tetris-state.json
          git commit -m "Update Tetris Game" || echo "No changes to commit"
          git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:output --force
      
      - name: Close Issue
        uses: peter-evans/close-issue@v2
        with:
          comment: "Move processed! Check out the updated game on the profile README."
